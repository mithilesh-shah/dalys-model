group_by(location, year) %>%
mutate(survival = cumprod(1 - pmin(mortality, 1))) %>%
summarise(pop = sum(population), LE_birth = sum(survival))
LE_birth_results
LE_birth_results <- mortality_data %>%
group_by(location, year) %>%
mutate(survival = cumprod(1 - pmin(mortality_proj_new/1e5, 1))) %>%
summarise(LE_birth_new = sum(survival))
dN_dmu_results,
forecasts_both %>% mutate(age = aa) %>%
group_by(location, year, age) %>%
summarise(pop_new = sum(population)) %>%
left_join(LE_birth_results) %>%
right_join(pops_base)
x<- forecasts_both %>% mutate(age = aa) %>%
group_by(location, year, age) %>%
summarise(pop_new = sum(population)) %>%
left_join(LE_birth_results) %>%
right_join(pops_base)
View(x)
x$LE_birth
x$LE_birth_new
x$LE_birth_new - x$LE_birth
x$LE_birth_new - x$LE_birth*1000
x$LE_birth_new - x$LE_birth*100000000
(x$LE_birth_new - x$LE_birth)*100000000
(x$LE_birth_new - x$LE_birth)*1e5
pops_base <- forecasts_base %>%
group_by(location, year) %>%
mutate(survival = cumprod(1 - pmin(mortality, 1))) %>%
summarise(pop = sum(population), LE_birth = sum(survival))
dN_dmu_results <- tibble()
for (aa in 0:150){
print(str_c("Computing dN_Dmu for age ", aa))
mortality_data$mortality_proj_new <- mortality_data$mortality_proj
mortality_data$mortality_proj_new[which(mortality_data$age == aa)] <-
mortality_data$mortality_proj[which(mortality_data$age == aa)] - 0.0001#*mortality_data$mortality_proj[which(mortality_data$age == aa)]
forecasts_both <- forecast_dalys(population_df, fertility_df, mortality_data, disability_data, new = "mortality",
start_year = 2021, end_year = 2021+125, end_age = end_age,
no_births = FALSE, fertility_type = "fertility_med", loc_name = "Regions",
growth_transitions = TRUE, project_100plus = TRUE)
LE_birth_results <- mortality_data %>%
group_by(location, year) %>%
mutate(survival = cumprod(1 - pmin(mortality_proj_new/1e5, 1))) %>%
summarise(LE_birth_new = sum(survival))
dN_dmu_results <- rbind(dN_dmu_results,
x<- forecasts_both %>% mutate(age = aa) %>%
group_by(location, year, age) %>%
summarise(pop_new = sum(population)) %>%
left_join(LE_birth_results) %>%
right_join(pops_base)
)
}
dN_dmu_results
dN_dmu_results %>%
rbind(mutate(dN_dmu_results, location = "Global")) %>%
group_by(location, year, age) %>%
summarise(pop_new = sum(pop_new), pop = sum(pop)) %>%
filter(year %in% c(2022, 2050, 2100), location %in%  c("Global", "World Bank High Income", "World Bank Low Income")) %>%
mutate(dN_dmu = pop_new - pop) %>%
ggplot() + theme_bw() +
facet_wrap(~location, scales = "free_y") +
geom_line(aes(x = age, y = dN_dmu, color = factor(year)))
dLE_dmu_results %>%
rbind(mutate(dN_dmu_results, location = "Global")) %>%
group_by(location, year, age) %>%
summarise(LE_birth_new = sum(pop_new*LE_birth_new)/sum(pop_new), LE_birth = sum(pop*LE_birth)/sum(pop))
dN_dmu_results %>%
rbind(mutate(dN_dmu_results, location = "Global")) %>%
group_by(location, year, age) %>%
summarise(LE_birth_new = sum(pop_new*LE_birth_new)/sum(pop_new), LE_birth = sum(pop*LE_birth)/sum(pop))
dN_dmu_results %>%
rbind(mutate(dN_dmu_results, location = "Global")) %>%
group_by(location, year, age) %>%
summarise(LE_birth_new = sum(pop_new*LE_birth_new)/sum(pop_new), LE_birth = sum(pop*LE_birth)/sum(pop)) %>%
filter(year %in% c(2022, 2050, 2100), location %in%  c("Global", "World Bank High Income", "World Bank Low Income"))
dN_dmu_results %>%
rbind(mutate(dN_dmu_results, location = "Global")) %>%
group_by(location, year, age) %>%
summarise(LE_birth_new = sum(pop_new*LE_birth_new)/sum(pop_new), LE_birth = sum(pop*LE_birth)/sum(pop)) %>%
filter(year %in% c(2022, 2050, 2100), location %in%  c("Global", "World Bank High Income", "World Bank Low Income")) %>%
mutate(dLE_dmu = 1e5*(pop_new - pop))
dN_dmu_results %>%
rbind(mutate(dN_dmu_results, location = "Global")) %>%
group_by(location, year, age) %>%
summarise(LE_birth_new = sum(pop_new*LE_birth_new)/sum(pop_new), LE_birth = sum(pop*LE_birth)/sum(pop)) %>%
filter(year %in% c(2022, 2050, 2100), location %in%  c("Global", "World Bank High Income", "World Bank Low Income")) %>%
mutate(dLE_dmu = 1e5*(LE_birth_new - LE_birth))
dN_dmu_results %>%
rbind(mutate(dN_dmu_results, location = "Global")) %>%
group_by(location, year, age) %>%
summarise(LE_birth_new = sum(pop_new*LE_birth_new)/sum(pop_new), LE_birth = sum(pop*LE_birth)/sum(pop)) %>%
filter(year %in% c(2022, 2050, 2100), location %in%  c("Global", "World Bank High Income", "World Bank Low Income")) %>%
mutate(dLE_dmu = 1e5*(LE_birth_new - LE_birth)) %>%
ggplot() + theme_bw() +
facet_wrap(~location, scales = "free_y") +
geom_line(aes(x = age, y = dLE_dmu, color = factor(year)))
ggsave("figures/derivatives/dLE_dmu.pdf", width = 10, height = 4)
#Clear the environment
rm(list=ls(all=TRUE))
# Set number of periods
Q = 30
# Set period in which shock/shift will occur
s1 = 5
# Create vectors that will contain the simulated data
y = rep(0, Q) # Income/output
p = rep(0, Q) # Inflation rate
r = rep(0, Q) # Real interest rate
rs = rep(0, Q) # Stabilising interest rate
# Set starting parameter values
A = rep(10, Q) # Autonomous output
a1 = rep(0.3, Q)  # IS curve slope
alpha = rep(0.7, Q)  # Phillips curve slope
ye = rep(5, Q) # Equilibrium output
cost = rep(0, Q) # Inflation shock (as in Figure 3.9)
beta = rep(1, Q)     # Inflation aversion
pt = rep(2, Q) # Inflation target
chi = rep(0, Q) # CB credibility
# We can model a shock by changing some of the parameters above at some point in our simulation
# Decide what the shock is going to be (default is a positive AD shock)
A[s1:Q] = 12 # Change automomous output
a1[s1:Q] = 0.3  # Change IS curve slope
alpha[s1:Q] = 0.7  # Change Phillips curve slope
ye[s1:Q] = 5  # Change equilibrium output
cost[s1:Q] = 0 # Change in the inflation shock
beta[s1:Q] = 1  # Change inflation aversion
pt[s1:Q] = 2  # Change inflation target
chi[s1:Q] = 0  # Change CB credibility
# If you want another shock to hit later, you could change its value at some s2 > s1...
# If you want the shock to be temporary, then just change it at s1 and not afterwards, e.g. cost[s1] = 0
# Initialise endogenous variables at equilibrium values
y[1]=ye[1]
p[1]=pt[1]
rs[1]=(A[1] - ye[1])/a1[1]
r[1]=rs[1]
# Simulate the model by looping over Q time periods
for (t in 2:Q){
#(1) IS curve
y[t] = A[t] - a1[t]*r[t-1]
#(2) Phillips Curve
pe = chi*pt[t] + (1 - chi)*p[t-1]
p[t] = pe +alpha[t]*(y[t]-ye[t]) + cost[t]
#(3) Stabilising interest rate
rs[t] = (A[t] - ye[t])/a1[t]
#(4) Monetary policy rule, solved for r
a3=(a1[t]*(1/(beta[t]*alpha[t]) + alpha[t]))^(-1)
r[t] = rs[t] + a3*(p[t]-pt[t])
} # close time loop
plot(y, type="l", xlab = "Time", ylab = "Output")
title(main="Output Impulse Response", cex=0.8 ,line=2)
plot(p, type="l", xlab = "Time", ylab = "Inflation")
title(main="Inflation Impulse Response", cex=0.8 ,line=2)
plot(r, type="l", xlab = "Time", ylab = "Interest Rate")
title(main="Interest Rate Impulse Response", cex=0.8 ,line=2)
#Clear the environment
rm(list=ls(all=TRUE))
# Set number of periods
Q = 30
# Set period in which shock/shift will occur
s1 = 5
# Create vectors that will contain the simulated data
y = rep(0, Q) # Income/output
p = rep(0, Q) # Inflation rate
r = rep(0, Q) # Real interest rate
rs = rep(0, Q) # Stabilising interest rate
# Set starting parameter values
A = rep(10, Q) # Autonomous output
a1 = rep(0.3, Q)  # IS curve slope
alpha = rep(0.7, Q)  # Phillips curve slope
ye = rep(5, Q) # Equilibrium output
cost = rep(0, Q) # Inflation shock (as in Figure 3.9)
beta = rep(1, Q)     # Inflation aversion
pt = rep(2, Q) # Inflation target
chi = rep(0, Q) # CB credibility
# We can model a shock by changing some of the parameters above at some point in our simulation
# Decide what the shock is going to be (default is a positive AD shock)
A[s1:Q] = 12 # Change automomous output
a1[s1:Q] = 0.3  # Change IS curve slope
alpha[s1:Q] = 0.7  # Change Phillips curve slope
ye[s1:Q] = 5  # Change equilibrium output
cost[s1:Q] = 0 # Change in the inflation shock
beta[s1:Q] = 1  # Change inflation aversion
pt[s1:Q] = 2  # Change inflation target
chi[7:Q] = 1  # Change CB credibility
# If you want another shock to hit later, you could change its value at some s2 > s1...
# If you want the shock to be temporary, then just change it at s1 and not afterwards, e.g. cost[s1] = 0
# Initialise endogenous variables at equilibrium values
y[1]=ye[1]
p[1]=pt[1]
rs[1]=(A[1] - ye[1])/a1[1]
r[1]=rs[1]
# Simulate the model by looping over Q time periods
for (t in 2:Q){
#(1) IS curve
y[t] = A[t] - a1[t]*r[t-1]
#(2) Phillips Curve
pe = chi*pt[t] + (1 - chi)*p[t-1]
p[t] = pe +alpha[t]*(y[t]-ye[t]) + cost[t]
#(3) Stabilising interest rate
rs[t] = (A[t] - ye[t])/a1[t]
#(4) Monetary policy rule, solved for r
a3=(a1[t]*(1/(beta[t]*alpha[t]) + alpha[t]))^(-1)
r[t] = rs[t] + a3*(p[t]-pt[t])
} # close time loop
### Plot results
# Plot the output response over time
plot(y, type="l", xlab = "Time", ylab = "Output")
plot(p, type="l", xlab = "Time", ylab = "Inflation")
#Clear the environment
rm(list=ls(all=TRUE))
# Set number of periods
Q = 30
# Set period in which shock/shift will occur
s1 = 5
# Create vectors that will contain the simulated data
y = rep(0, Q) # Income/output
p = rep(0, Q) # Inflation rate
r = rep(0, Q) # Real interest rate
rs = rep(0, Q) # Stabilising interest rate
# Set starting parameter values
A = rep(10, Q) # Autonomous output
a1 = rep(0.3, Q)  # IS curve slope
alpha = rep(0.7, Q)  # Phillips curve slope
ye = rep(5, Q) # Equilibrium output
cost = rep(0, Q) # Inflation shock (as in Figure 3.9)
beta = rep(1, Q)     # Inflation aversion
pt = rep(2, Q) # Inflation target
chi = rep(0, Q) # CB credibility
# We can model a shock by changing some of the parameters above at some point in our simulation
# Decide what the shock is going to be (default is a positive AD shock)
A[s1:Q] = 12 # Change automomous output
a1[s1:Q] = 0.3  # Change IS curve slope
alpha[s1:Q] = 0.7  # Change Phillips curve slope
ye[s1:Q] = 5  # Change equilibrium output
cost[s1:Q] = 0 # Change in the inflation shock
beta[s1:Q] = 1  # Change inflation aversion
pt[s1:Q] = 2  # Change inflation target
chi[7:Q] = 1  # Change CB credibility
# If you want another shock to hit later, you could change its value at some s2 > s1...
# If you want the shock to be temporary, then just change it at s1 and not afterwards, e.g. cost[s1] = 0
# Initialise endogenous variables at equilibrium values
y[1]=ye[1]
p[1]=pt[1]
rs[1]=(A[1] - ye[1])/a1[1]
r[1]=rs[1]
# Simulate the model by looping over Q time periods
for (t in 2:Q){
#(1) IS curve
y[t] = A[t] - a1[t]*r[t-1]
#(2) Phillips Curve
pe = chi[t]*pt[t] + (1 - chi)*p[t-1]
p[t] = pe +alpha[t]*(y[t]-ye[t]) + cost[t]
#(3) Stabilising interest rate
rs[t] = (A[t] - ye[t])/a1[t]
#(4) Monetary policy rule, solved for r
a3=(a1[t]*(1/(beta[t]*alpha[t]) + alpha[t]))^(-1)
r[t] = rs[t] + a3*(p[t]-pt[t])
} # close time loop
### Plot results
# Plot the output response over time
plot(y, type="l", xlab = "Time", ylab = "Output")
title(main="Output Impulse Response", cex=0.8 ,line=2)
plot(p, type="l", xlab = "Time", ylab = "Inflation")
title(main="Inflation Impulse Response", cex=0.8 ,line=2)
#Clear the environment
rm(list=ls(all=TRUE))
# Set number of periods
Q = 30
# Set period in which shock/shift will occur
s1 = 5
# Create vectors that will contain the simulated data
y = rep(0, Q) # Income/output
p = rep(0, Q) # Inflation rate
r = rep(0, Q) # Real interest rate
rs = rep(0, Q) # Stabilising interest rate
# Set starting parameter values
A = rep(10, Q) # Autonomous output
a1 = rep(0.3, Q)  # IS curve slope
alpha = rep(0.7, Q)  # Phillips curve slope
ye = rep(5, Q) # Equilibrium output
cost = rep(0, Q) # Inflation shock (as in Figure 3.9)
beta = rep(1, Q)     # Inflation aversion
pt = rep(2, Q) # Inflation target
# We can model a shock by changing some of the parameters above at some point in our simulation
# Decide what the shock is going to be (default is a positive AD shock)
A[s1:Q] = 12 # Change automomous output
a1[s1:Q] = 0.3  # Change IS curve slope
alpha[s1:Q] = 0.7  # Change Phillips curve slope
ye[s1:Q] = 5  # Change equilibrium output
cost[s1:Q] = 0 # Change in the inflation shock
beta[s1:Q] = 1  # Change inflation aversion
pt[s1:Q] = 2  # Change inflation target
# If you want another shock to hit later, you could change its value at some s2 > s1...
# If you want the shock to be temporary, then just change it at s1 and not afterwards, e.g. cost[s1] = 0
# Initialise endogenous variables at equilibrium values
y[1]=ye[1]
p[1]=pt[1]
rs[1]=(A[1] - ye[1])/a1[1]
r[1]=rs[1]
# Simulate the model by looping over Q time periods
for (t in 2:Q){
#(1) IS curve
y[t] = A[t] - a1[t]*r[t-1]
#(2) Phillips Curve
p[t] = p[t-1] +alpha[t]*(y[t]-ye[t]) + cost[t]
#(3) Stabilising interest rate
rs[t] = (A[t] - ye[t])/a1[t]
#(4) Monetary policy rule, solved for r
a3=(a1[t]*(1/(beta[t]*alpha[t]) + alpha[t]))^(-1)
r[t] = rs[t] + a3*(p[t]-pt[t])
} # close time loop
### Plot results
# Plot the output response over time
plot(y, type="l", xlab = "Time", ylab = "Output")
title(main="Output Impulse Response", cex=0.8 ,line=2)
# Plot the inflation response over time
plot(p, type="l", xlab = "Time", ylab = "Inflation")
title(main="Inflation Impulse Response", cex=0.8 ,line=2)
# Policy rate under different scenarios
plot(r, type="l", xlab = "Time", ylab = "Interest Rate")
title(main="Interest Rate Impulse Response", cex=0.8 ,line=2)
#Clear the environment
rm(list=ls(all=TRUE))
# Set number of periods
Q = 30
# Set period in which shock/shift will occur
s1 = 5
# Create vectors that will contain the simulated data
y = rep(0, Q) # Income/output
p = rep(0, Q) # Inflation rate
r = rep(0, Q) # Real interest rate
rs = rep(0, Q) # Stabilising interest rate
# Set starting parameter values
A = rep(10, Q) # Autonomous output
a1 = rep(0.3, Q)  # IS curve slope
alpha = rep(0.7, Q)  # Phillips curve slope
ye = rep(5, Q) # Equilibrium output
cost = rep(0, Q) # Inflation shock (as in Figure 3.9)
beta = rep(1, Q)     # Inflation aversion
pt = rep(2, Q) # Inflation target
# We can model a shock by changing some of the parameters above at some point in our simulation
# Decide what the shock is going to be (default is a positive AD shock)
A[s1:Q] = 12 # Change automomous output
a1[s1:Q] = 0.3  # Change IS curve slope
alpha[s1:Q] = 0.7  # Change Phillips curve slope
ye[(s1+5):Q] = 4  # Change equilibrium output
cost[s1:Q] = 0 # Change in the inflation shock
beta[s1:Q] = 1  # Change inflation aversion
pt[s1:Q] = 2  # Change inflation target
# If you want another shock to hit later, you could change its value at some s2 > s1...
# If you want the shock to be temporary, then just change it at s1 and not afterwards, e.g. cost[s1] = 0
# Initialise endogenous variables at equilibrium values
y[1]=ye[1]
p[1]=pt[1]
rs[1]=(A[1] - ye[1])/a1[1]
r[1]=rs[1]
# Simulate the model by looping over Q time periods
for (t in 2:Q){
#(1) IS curve
y[t] = A[t] - a1[t]*r[t-1]
#(2) Phillips Curve
p[t] = p[t-1] +alpha[t]*(y[t]-ye[t]) + cost[t]
#(3) Stabilising interest rate
rs[t] = (A[t] - ye[t])/a1[t]
#(4) Monetary policy rule, solved for r
a3=(a1[t]*(1/(beta[t]*alpha[t]) + alpha[t]))^(-1)
r[t] = rs[t] + a3*(p[t]-pt[t])
} # close time loop
plot(y, type="l", xlab = "Time", ylab = "Output")
title(main="Output Impulse Response", cex=0.8 ,line=2)
plot(p, type="l", xlab = "Time", ylab = "Inflation")
title(main="Inflation Impulse Response", cex=0.8 ,line=2)
plot(r, type="l", xlab = "Time", ylab = "Interest Rate")
title(main="Interest Rate Impulse Response", cex=0.8 ,line=2)
#Clear the environment
rm(list=ls(all=TRUE))
Q = 30
s1 = 5
y = rep(0, Q) # Income/output
p = rep(0, Q) # Inflation rate
r = rep(0, Q) # Real interest rate
rs = rep(0, Q) # Stabilising interest rate
A = rep(10, Q) # Autonomous output
a1 = rep(0.3, Q)  # IS curve slope
alpha = rep(0.7, Q)  # Phillips curve slope
ye = rep(5, Q) # Equilibrium output
cost = rep(0, Q) # Inflation shock (as in Figure 3.9)
beta = rep(1, Q)     # Inflation aversion
pt = rep(2, Q) # Inflation target
A
beta
A[s1:Q] = 12 # Change automomous output
a1[s1:Q] = 0.3  # Change IS curve slope
alpha[s1:Q] = 0.7  # Change Phillips curve slope
ye[(s1+5):Q] = 4  # Change equilibrium output
cost[s1:Q] = 0 # Change in the inflation shock
beta[s1:Q] = 1  # Change inflation aversion
pt[s1:Q] = 2  # Change inflation target
# If you want another shock to hit later, you could change its value at some s2 > s1...
# If you want the shock to be temporary, then just change it at s1 and not afterwards, e.g. cost[s1] = 0
A
# Initialise endogenous variables at equilibrium values
y[1]=ye[1]
p[1]=pt[1]
rs[1]=(A[1] - ye[1])/a1[1]
r[1]=rs[1]
# Simulate the model by looping over Q time periods
for (t in 2:Q){
#(1) IS curve
y[t] = A[t] - a1[t]*r[t-1]
#(2) Phillips Curve
p[t] = p[t-1] +alpha[t]*(y[t]-ye[t]) + cost[t]
#(3) Stabilising interest rate
rs[t] = (A[t] - ye[t])/a1[t]
#(4) Monetary policy rule, solved for r
a3=(a1[t]*(1/(beta[t]*alpha[t]) + alpha[t]))^(-1)
r[t] = rs[t] + a3*(p[t]-pt[t])
} # close time loop
plot(y, type="l", xlab = "Time", ylab = "Output")
title(main="Output Impulse Response", cex=0.8 ,line=2)
plot(p, type="l", xlab = "Time", ylab = "Inflation")
title(main="Inflation Impulse Response", cex=0.8 ,line=2)
plot(r, type="l", xlab = "Time", ylab = "Interest Rate")
title(main="Interest Rate Impulse Response", cex=0.8 ,line=2)
A[s1:(s1+10)] = 12 # Change automomous output
#Clear the environment
rm(list=ls(all=TRUE))
# Set number of periods
Q = 30
# Set period in which shock/shift will occur
s1 = 5
# Create vectors that will contain the simulated data
y = rep(0, Q) # Income/output
p = rep(0, Q) # Inflation rate
r = rep(0, Q) # Real interest rate
rs = rep(0, Q) # Stabilising interest rate
# Set starting parameter values
A = rep(10, Q) # Autonomous output
a1 = rep(0.3, Q)  # IS curve slope
alpha = rep(0.7, Q)  # Phillips curve slope
ye = rep(5, Q) # Equilibrium output
cost = rep(0, Q) # Inflation shock (as in Figure 3.9)
beta = rep(1, Q)     # Inflation aversion
pt = rep(2, Q) # Inflation target
# We can model a shock by changing some of the parameters above at some point in our simulation
# Decide what the shock is going to be (default is a positive AD shock)
A[s1:(s1+10)] = 12 # Change automomous output
a1[s1:Q] = 0.3  # Change IS curve slope
alpha[s1:Q] = 0.7  # Change Phillips curve slope
ye[(s1+5):Q] = 4  # Change equilibrium output
cost[s1:Q] = 0 # Change in the inflation shock
beta[s1:Q] = 1  # Change inflation aversion
pt[s1:Q] = 2  # Change inflation target
# If you want another shock to hit later, you could change its value at some s2 > s1...
# If you want the shock to be temporary, then just change it at s1 and not afterwards, e.g. cost[s1] = 0
# Initialise endogenous variables at equilibrium values
y[1]=ye[1]
p[1]=pt[1]
rs[1]=(A[1] - ye[1])/a1[1]
r[1]=rs[1]
# Simulate the model by looping over Q time periods
for (t in 2:Q){
#(1) IS curve
y[t] = A[t] - a1[t]*r[t-1]
#(2) Phillips Curve
p[t] = p[t-1] +alpha[t]*(y[t]-ye[t]) + cost[t]
#(3) Stabilising interest rate
rs[t] = (A[t] - ye[t])/a1[t]
#(4) Monetary policy rule, solved for r
a3=(a1[t]*(1/(beta[t]*alpha[t]) + alpha[t]))^(-1)
r[t] = rs[t] + a3*(p[t]-pt[t])
} # close time loop
### Plot results
# Plot the output response over time
plot(y, type="l", xlab = "Time", ylab = "Output")
title(main="Output Impulse Response", cex=0.8 ,line=2)
y = rep(0, Q) # Income/output
y
r = rep(0, Q) # Real interest rate
A = rep(10, Q) # Autonomous output
A
A[s1:(s1+10)] = 12 # Change automomous output
A
ye[(s1+5):Q] = 4  # Change equilibrium output
ye
# Initialise endogenous variables at equilibrium values
y[1]=ye[1]
p[1]=pt[1]
rs[1]=(A[1] - ye[1])/a1[1]
r[1]=rs[1]
# Simulate the model by looping over Q time periods
for (t in 2:Q){
#(1) IS curve
y[t] = A[t] - a1[t]*r[t-1]
#(2) Phillips Curve
p[t] = p[t-1] +alpha[t]*(y[t]-ye[t]) + cost[t]
#(3) Stabilising interest rate
rs[t] = (A[t] - ye[t])/a1[t]
#(4) Monetary policy rule, solved for r
a3=(a1[t]*(1/(beta[t]*alpha[t]) + alpha[t]))^(-1)
r[t] = rs[t] + a3*(p[t]-pt[t])
} # close time loop
### Plot results
# Plot the output response over time
plot(y, type="l", xlab = "Time", ylab = "Output")
title(main="Output Impulse Response", cex=0.8 ,line=2)
# Plot the inflation response over time
plot(p, type="l", xlab = "Time", ylab = "Inflation")
title(main="Inflation Impulse Response", cex=0.8 ,line=2)
# Policy rate under different scenarios
plot(r, type="l", xlab = "Time", ylab = "Interest Rate")
title(main="Interest Rate Impulse Response", cex=0.8 ,line=2)
